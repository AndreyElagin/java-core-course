[Лекции здесь](https://yadi.sk/d/Eo744cD23TxQZW)
[Примеры кода с лекций](https://github.com/AndreyElagin/java-core-course/tree/master/src/main/java/com/epam/classwork)

Настройки

- включить галочку `Enable annotation processing` в `File | Settings | Build, Execution, Deployment | Compiler | Annotation Processors`
- установить плагин для Intellij Idea - `Lombok`, это можно сделать в `File | Settings | Plugins` во вкладке `Marketplace`, после установки перезагрузить IDE

Workflow по задачам

1. Создаем branch c именем в формате `taskN`, где `N` номер задачи
2. Пишем решение задачи непосредствнно в файле с условием
3. Пишем тесты в соотвествуюещем файле `TaskNTTest`, где `N` номер задачи
4. Через интерфейс github создаем pull request в ветку master (строго один pull request на одну задачу)

Как пишем тесты

Все тесты которые ожидают ввод с консоли имеют специальный wrapper реализованный индивидуально под каждую задачу (в детали его реализии вникать не стоит). Все что требуется это для каждого задания реализовать n методов которые бы тестировали некоторые граничные условия. Пример:

```java
class Task1TTest {   

    @Test
    void checkStringsWithDifferentLengths() {
        test("W", "Ww", "W", "Ww"); 
    }
}
```

В теле метода могут быть произвольные операции, но главное что там обязательно должен быть один вызов метода `test()` который будет учитывать контекст конкретного задания. Тоесть если, например, надо подготовить тестовые данные для передачи в метод `test()` то их можно подготовать выше вызова этого метода.

Именовать тестовые методы нужно в соответсвии с тем какой кейс они проверяют, например, `checkStringsWithDifferentLengths()` явно говорит что мы хотим проверить строки с разной длинной и данное название имеет смысл только в контексте конкретного теста.

